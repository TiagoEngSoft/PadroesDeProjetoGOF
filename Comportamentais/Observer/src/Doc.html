<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <title>PadrÃ£o Observer â€” EstaÃ§Ã£o MeteorolÃ³gica</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #fafafa;
            color: #333;
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }

        header {
            background: #ff5722;
            color: white;
            padding: 20px;
            text-align: center;
        }

        main {
            max-width: 800px;
            margin: auto;
            padding: 20px;
        }

        h2 {
            color: #ff5722;
            margin-top: 40px;
        }

        .box {
            background: #f1f1f1;
            border-left: 6px solid #ff5722;
            padding: 15px;
            margin: 20px 0;
        }

        pre {
            background: #272822;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
        }

        code {
            font-family: monospace;
        }

        ul {
            padding-left: 20px;
        }

        footer {
            background: #eee;
            padding: 20px;
            text-align: center;
            margin-top: 40px;
        }
    </style>
</head>

<body>

    <header>
        <h1>ğŸŒ¦ï¸ PadrÃ£o de Projeto: Observer</h1>
        <p>Notificando mÃºltiplos objetos automaticamente ao mudar o estado</p>
    </header>

    <main>

        <h2>âœ… DefiniÃ§Ã£o formal do padrÃ£o Observer (GOF)</h2>
        <div class="box">
            O padrÃ£o <strong>Observer</strong> define uma dependÃªncia um-para-muitos entre objetos,
            de modo que quando um objeto muda de estado, todos os seus dependentes sÃ£o notificados automaticamente.
        </div>

        <h2>ğŸ¤” Explicando de forma simples</h2>
        <div class="box">
            Imagine uma <strong>estaÃ§Ã£o meteorolÃ³gica</strong> que mede a temperatura. Sempre que ela registra
            uma nova temperatura, <strong>todos os painÃ©is de exibiÃ§Ã£o conectados devem atualizar o valor
                mostrado</strong>.<br><br>
            O padrÃ£o Observer faz exatamente isso: permite que mÃºltiplos objetos "observem" um objeto central,
            e sejam atualizados sempre que houver uma mudanÃ§a.
        </div>

        <h2>ğŸ’¡ Nosso Exemplo: EstaÃ§Ã£o MeteorolÃ³gica</h2>
        <ul>
            <li><strong>Subject:</strong> Interface para os objetos observados (a estaÃ§Ã£o)</li>
            <li><strong>Observer:</strong> Interface que todos os "observadores" devem implementar</li>
            <li><strong>WeatherStation:</strong> A estaÃ§Ã£o que notifica os observadores</li>
            <li><strong>TemperatureDisplay:</strong> Um painel que exibe a temperatura</li>
            <li><strong>Main:</strong> Simula o funcionamento</li>
        </ul>

        <h2>ğŸ“¦ Estrutura do Projeto</h2>
        <pre><code>
src/
â”œâ”€â”€ observer/
â”‚   â”œâ”€â”€ Subject.java
â”‚   â”œâ”€â”€ Observer.java
â”‚   â”œâ”€â”€ WeatherStation.java
â”‚   â””â”€â”€ TemperatureDisplay.java
â””â”€â”€ Main.java
        </code></pre>

        <h2>ğŸ§ª CÃ³digo Exemplo</h2>

        <h3>Subject.java</h3>
        <pre><code>public interface Subject {
    void registrarObserver(Observer o);
    void removerObserver(Observer o);
    void notificarObservers();
}
</code></pre>

        <h3>Observer.java</h3>
        <pre><code>public interface Observer {
    void atualizar(float temperatura);
}
</code></pre>

        <h3>WeatherStation.java</h3>
        <pre><code>public class WeatherStation implements Subject {
    private List&lt;Observer&gt; observers = new ArrayList<>();
    private float temperatura;

    public void registrarObserver(Observer o) {
        observers.add(o);
    }

    public void removerObserver(Observer o) {
        observers.remove(o);
    }

    public void notificarObservers() {
        for (Observer o : observers) {
            o.atualizar(temperatura);
        }
    }

    public void setTemperatura(float novaTemperatura) {
        this.temperatura = novaTemperatura;
        notificarObservers();
    }
}
</code></pre>

        <h3>TemperatureDisplay.java</h3>
        <pre><code>public class TemperatureDisplay implements Observer {
    private String nome;

    public TemperatureDisplay(String nome) {
        this.nome = nome;
    }

    public void atualizar(float temperatura) {
        System.out.println("[" + nome + "] Temperatura atualizada: " + temperatura + "Â°C");
    }
}
</code></pre>

        <h3>Main.java</h3>
        <pre><code>public class Main {
    public static void main(String[] args) {
        WeatherStation estacao = new WeatherStation();

        TemperatureDisplay tela1 = new TemperatureDisplay("Tela 1");
        TemperatureDisplay tela2 = new TemperatureDisplay("Tela 2");

        estacao.registrarObserver(tela1);
        estacao.registrarObserver(tela2);

        estacao.setTemperatura(25.0f);
        estacao.setTemperatura(30.5f);

        estacao.removerObserver(tela2);
        estacao.setTemperatura(27.0f);
    }
}
</code></pre>

        <h2>ğŸ§  Explicando o CÃ³digo Passo a Passo</h2>
        <div class="box">
            <p>Aqui vai a explicaÃ§Ã£o detalhada, linha por linha:</p>

            <ul>
                <li>
                    <strong>ğŸ“¡ Subject (interface):</strong><br>
                    Define os mÃ©todos que qualquer objeto "observÃ¡vel" deve ter:
                    <ul>
                        <li><code>registrarObserver()</code> â€“ adiciona um observador</li>
                        <li><code>removerObserver()</code> â€“ remove um observador</li>
                        <li><code>notificarObservers()</code> â€“ avisa todos os observadores sobre uma mudanÃ§a</li>
                    </ul>
                    Serve como contrato: qualquer "sujeito" deve seguir essas regras.
                </li>
                <br>

                <li>
                    <strong>ğŸ‘ï¸ Observer (interface):</strong><br>
                    Define o mÃ©todo que os observadores precisam implementar:
                    <ul>
                        <li><code>atualizar(temperatura)</code> â€“ chamado sempre que o sujeito muda de estado</li>
                    </ul>
                    Isso garante que todos os "displays", "painÃ©is", etc., saibam o que fazer quando forem avisados.
                </li>
                <br>

                <li>
                    <strong>ğŸŒ¡ï¸ WeatherStation:</strong><br>
                    Esta Ã© a classe principal do sistema â€” o objeto observado.<br>
                    Ela:
                    <ul>
                        <li>Armazena a lista de observadores</li>
                        <li>Tem um mÃ©todo <code>setTemperatura()</code> que altera o estado</li>
                        <li>Chama <code>notificarObservers()</code> toda vez que o valor Ã© alterado</li>
                    </ul>
                    Ou seja, sempre que a temperatura muda, todos os observadores sÃ£o informados automaticamente.
                </li>
                <br>

                <li>
                    <strong>ğŸ“º TemperatureDisplay:</strong><br>
                    Ã‰ um observador que implementa o mÃ©todo <code>atualizar()</code>.<br>
                    Quando a estaÃ§Ã£o avisa, ele mostra a nova temperatura.
                    <br>
                    VocÃª pode criar quantos displays quiser â€” todos vÃ£o receber as atualizaÃ§Ãµes.
                </li>
                <br>

                <li>
                    <strong>ğŸš€ Main.java:</strong><br>
                    Ã‰ onde tudo acontece:
                    <ul>
                        <li>Criamos a estaÃ§Ã£o meteorolÃ³gica</li>
                        <li>Registramos duas "telas de exibiÃ§Ã£o"</li>
                        <li>Alteramos a temperatura 3 vezes</li>
                        <li>Removemos uma tela antes da Ãºltima atualizaÃ§Ã£o</li>
                    </ul>
                    Observe que apenas as telas registradas sÃ£o notificadas.
                </li>
            </ul>
        </div>

        <h2>âœ… BenefÃ­cios do Observer</h2>
        <div class="box">
            <ul>
                <li>ğŸ”„ AtualizaÃ§Ãµes automÃ¡ticas sem acoplamento entre objetos</li>
                <li>ğŸ‘¥ Suporte fÃ¡cil a mÃºltiplos assinantes (observers)</li>
                <li>ğŸ§± Estrutura modular e escalÃ¡vel</li>
                <li>ğŸ”” Excelente para interfaces grÃ¡ficas, sistemas de eventos, notificaÃ§Ãµes etc.</li>
            </ul>
        </div>

        <h2>âš ï¸ Cuidados</h2>
        <div class="box">
            <ul>
                <li>âš ï¸ Pode haver muitos observers â€” gerencie com cuidado</li>
                <li>ğŸŒ€ Loops infinitos podem ocorrer se um observer alterar o sujeito</li>
                <li>ğŸ§ª Testes devem cobrir os fluxos de notificaÃ§Ã£o</li>
            </ul>
        </div>

        <h2>ğŸ“Œ ConclusÃ£o</h2>
        <div class="box">
            O padrÃ£o <strong>Observer</strong> separa claramente quem emite os dados (sujeito)
            de quem os consome (observadores).<br><br>
            Isso permite notificaÃ§Ãµes em tempo real e sistemas reativos â€” tudo sem depender diretamente de quem estÃ¡
            observando.
        </div>

    </main>

    <footer>
        <p>PadrÃµes de Projeto em Java â€¢ Observer â€¢ 2025</p>
    </footer>
</body>

</html>