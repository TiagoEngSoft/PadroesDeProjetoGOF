<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8" />
    <title>Padr√£o Visitor ‚Äî Visitando Objetos</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #fafafa;
            color: #333;
            margin: 0;
            padding: 0;
            line-height: 1.6;
        }

        header {
            background: #673ab7;
            color: white;
            padding: 20px;
            text-align: center;
        }

        main {
            max-width: 800px;
            margin: auto;
            padding: 20px;
        }

        h2 {
            color: #673ab7;
            margin-top: 40px;
        }

        .box {
            background: #f1f1f1;
            border-left: 6px solid #673ab7;
            padding: 15px;
            margin: 20px 0;
        }

        pre {
            background: #272822;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
        }

        code {
            font-family: monospace;
        }

        ul {
            padding-left: 20px;
        }

        footer {
            background: #eee;
            padding: 20px;
            text-align: center;
            margin-top: 40px;
        }
    </style>
</head>

<body>

    <header>
        <h1>üëÅÔ∏è‚Äçüó®Ô∏è Padr√£o de Projeto: Visitor</h1>
        <p>Separar algoritmos de objetos para adicionar opera√ß√µes sem alterar suas classes</p>
    </header>

    <main>
        <h2>‚úÖ Defini√ß√£o formal do padr√£o Visitor (GOF)</h2>
        <div class="box">
            <strong>Visitor</strong> √© um padr√£o comportamental que permite definir uma nova opera√ß√£o sem mudar as
            classes dos objetos sobre os quais opera.
            Ele desacopla o algoritmo dos objetos visitados, facilitando a adi√ß√£o de novas funcionalidades.
        </div>

        <h2>ü§î O que √© o Visitor de forma simples?</h2>
        <div class="box">
            Imagine que voc√™ tem v√°rios tipos de objetos diferentes, como Pessoas e Empresas.<br /><br />
            Quer executar opera√ß√µes sobre eles (por exemplo, imprimir detalhes), mas sem modificar suas classes
            originais.<br /><br />
            O <strong>Visitor</strong> permite criar "visitantes" que passam por esses objetos e realizam a√ß√µes
            espec√≠ficas para cada tipo, mantendo as classes limpas e focadas em seus dados.
        </div>

        <h2>üí° Nosso Exemplo: Visitando Pessoas e Empresas</h2>
        <ul>
            <li><strong>Elemento (interface):</strong> Define o m√©todo <code>aceitar(Visitor visitor)</code> para
                aceitar visitantes.</li>
            <li><strong>Pessoa e Empresa:</strong> Implementam <code>Elemento</code> e permitem que visitantes realizem
                opera√ß√µes espec√≠ficas.</li>
            <li><strong>Visitor (interface):</strong> Declara m√©todos para visitar cada tipo de elemento.</li>
            <li><strong>ImpressaoVisitor:</strong> Implementa a interface <code>Visitor</code>, imprimindo detalhes dos
                objetos.</li>
            <li><strong>Main:</strong> Cria elementos e um visitor, e aplica a opera√ß√£o a cada elemento.</li>
        </ul>

        <h2>üì¶ Estrutura do Projeto</h2>
        <pre><code>
src/
‚îú‚îÄ‚îÄ visitor/
‚îÇ   ‚îú‚îÄ‚îÄ Elemento.java
‚îÇ   ‚îú‚îÄ‚îÄ Pessoa.java
‚îÇ   ‚îú‚îÄ‚îÄ Empresa.java
‚îÇ   ‚îú‚îÄ‚îÄ Visitor.java
‚îÇ   ‚îî‚îÄ‚îÄ ImpressaoVisitor.java
‚îî‚îÄ‚îÄ Main.java
        </code></pre>

        <h2>üß™ C√≥digo Exemplo</h2>

        <h3>Interface Elemento</h3>
        <pre><code>package visitor;

// Elemento que aceita visitantes
public interface Elemento {
    void aceitar(Visitor visitor);
}
</code></pre>

        <h3>Classe Pessoa</h3>
        <pre><code>package visitor;

public class Pessoa implements Elemento {
    private String nome;
    private int idade;

    public Pessoa(String nome, int idade) {
        this.nome = nome;
        this.idade = idade;
    }

    public String getNome() { return nome; }
    public int getIdade() { return idade; }

    @Override
    public void aceitar(Visitor visitor) {
        visitor.visitarPessoa(this);
    }
}
</code></pre>

        <h3>Classe Empresa</h3>
        <pre><code>package visitor;

public class Empresa implements Elemento {
    private String nome;
    private int funcionarios;

    public Empresa(String nome, int funcionarios) {
        this.nome = nome;
        this.funcionarios = funcionarios;
    }

    public String getNome() { return nome; }
    public int getFuncionarios() { return funcionarios; }

    @Override
    public void aceitar(Visitor visitor) {
        visitor.visitarEmpresa(this);
    }
}
</code></pre>

        <h3>Interface Visitor</h3>
        <pre><code>package visitor;

// Interface Visitor declara m√©todos para visitar tipos diferentes
public interface Visitor {
    void visitarPessoa(Pessoa pessoa);
    void visitarEmpresa(Empresa empresa);
}
</code></pre>

        <h3>Implementa√ß√£o ImpressaoVisitor</h3>
        <pre><code>package visitor;

public class ImpressaoVisitor implements Visitor {

    @Override
    public void visitarPessoa(Pessoa pessoa) {
        System.out.println("Visitando Pessoa: " + pessoa.getNome() + ", idade: " + pessoa.getIdade());
    }

    @Override
    public void visitarEmpresa(Empresa empresa) {
        System.out.println("Visitando Empresa: " + empresa.getNome() + ", funcion√°rios: " + empresa.getFuncionarios());
    }
}
</code></pre>

        <h3>Classe Main (Teste)</h3>
        <pre><code>import visitor.*;

public class Main {
    public static void main(String[] args) {
        Elemento[] elementos = {
            new Pessoa("Alice", 30),
            new Empresa("OpenAI", 500)
        };

        Visitor visitor = new ImpressaoVisitor();

        for (Elemento e : elementos) {
            e.aceitar(visitor);
        }
    }
}
</code></pre>

        <h2>üß† Explicando o C√≥digo Passo a Passo</h2>
        <div class="box">
            <ul>
                <li><strong>1Ô∏è‚É£ Interface Elemento:</strong> Define um m√©todo <code>aceitar(Visitor visitor)</code>.
                    Isso permite que um visitante seja ‚Äúaceito‚Äù e aplique opera√ß√µes ao objeto.</li>

                <li><strong>2Ô∏è‚É£ Classes Concretas (Pessoa, Empresa):</strong> Implementam <code>Elemento</code> e dentro
                    do m√©todo <code>aceitar</code> chamam o m√©todo apropriado do visitor, passando <em>this</em> (a si
                    mesmo).</li>

                <li><strong>3Ô∏è‚É£ Interface Visitor:</strong> Declara um m√©todo para visitar cada tipo de elemento,
                    garantindo que a opera√ß√£o correta ser√° chamada.</li>

                <li><strong>4Ô∏è‚É£ ImpressaoVisitor:</strong> Implementa o visitor e define a opera√ß√£o que ser√° feita para
                    cada tipo ‚Äî no caso, imprimir detalhes no console.</li>

                <li><strong>5Ô∏è‚É£ Main:</strong> Cria elementos e um visitor. Para cada elemento, chama
                    <code>aceitar(visitor)</code>, que executa a opera√ß√£o apropriada sem que os elementos precisem
                    conhecer os detalhes da opera√ß√£o.</li>
            </ul>
        </div>

        <h2>‚úÖ Benef√≠cios do Visitor</h2>
        <div class="box">
            <ul>
                <li>üîπ Permite adicionar novas opera√ß√µes sem alterar as classes dos elementos.</li>
                <li>üîπ Mant√©m a l√≥gica separada dos dados, melhorando organiza√ß√£o.</li>
                <li>üîπ Facilita adicionar funcionalidades a objetos complexos com muitos tipos.</li>
                <li>üîπ Ajuda a cumprir o princ√≠pio aberto-fechado (Open/Closed Principle).</li>
            </ul>
        </div>

        <h2>‚ö†Ô∏è Cuidados</h2>
        <div class="box">
            <ul>
                <li>‚ö†Ô∏è Pode ser complicado adicionar novos tipos de elementos, pois a interface Visitor deve ser
                    atualizada.</li>
                <li>‚ö†Ô∏è Se os elementos mudarem com frequ√™ncia, o padr√£o pode se tornar dif√≠cil de manter.</li>
            </ul>
        </div>

        <h2>üìå Conclus√£o</h2>
        <div class="box">
            O padr√£o <strong>Visitor</strong> √© muito √∫til para adicionar opera√ß√µes complexas a objetos heterog√™neos,
            sem modificar suas classes originais.<br /><br />
            Ele separa claramente os dados da l√≥gica, promovendo c√≥digo organizado e extens√≠vel, ideal para sistemas que
            precisam evoluir com novas funcionalidades sem quebrar o c√≥digo existente.
        </div>
    </main>

    <footer>
        <p>Padr√µes de Projeto em Java ‚Ä¢ Visitor ‚Ä¢ 2025</p>
    </footer>
</body>

</html>